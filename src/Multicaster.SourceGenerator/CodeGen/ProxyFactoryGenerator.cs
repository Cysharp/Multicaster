using System.Text;
using Cysharp.Runtime.Multicast.SourceGenerator.CodeAnalysis;

namespace Cysharp.Runtime.Multicast.SourceGenerator.CodeGen;

/// <summary>
/// Generates the main proxy factory class that implements IInMemoryProxyFactory and IRemoteProxyFactory.
/// </summary>
public static class ProxyFactoryGenerator
{
    public static string Generate(
        string namespaceName,
        string className,
        IReadOnlyList<ReceiverInterfaceInfo> receivers)
    {
        var sb = new StringBuilder();

        // Header
        sb.AppendLine("""
            // <auto-generated />
            #pragma warning disable CS0618 // Obsolete
            #pragma warning disable CS0612 // Obsolete
            #pragma warning disable CS8019 // Unnecessary using
            #nullable enable

            using System;
            using System.Collections.Immutable;
            using System.Threading;
            using System.Threading.Tasks;

            """);

        // Namespace
        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        // Main class implementing both factory interfaces
        GenerateMainClass(sb, className, receivers);

        // Generate proxy classes for each receiver
        foreach (var receiver in receivers)
        {
            sb.AppendLine();
            sb.Append(InMemoryProxyGenerator.Generate(receiver));
            sb.AppendLine();
            sb.Append(RemoteProxyGenerator.Generate(receiver));
        }

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine("}");
        }

        return sb.ToString();
    }

    static void GenerateMainClass(StringBuilder sb, string className, IReadOnlyList<ReceiverInterfaceInfo> receivers)
    {
        var indent = "    ";

        sb.AppendLine($"{indent}partial class {className} : global::Cysharp.Runtime.Multicast.InMemory.IInMemoryProxyFactory, global::Cysharp.Runtime.Multicast.Remoting.IRemoteProxyFactory");
        sb.AppendLine($"{indent}{{");

        // IInMemoryProxyFactory.Create<TKey, T>
        sb.AppendLine($"{indent}    /// <inheritdoc />");
        sb.AppendLine($"{indent}    public T Create<TKey, T>(");
        sb.AppendLine($"{indent}        global::Cysharp.Runtime.Multicast.InMemory.IReceiverHolder<TKey, T> receivers,");
        sb.AppendLine($"{indent}        global::System.Collections.Immutable.ImmutableArray<TKey> excludes,");
        sb.AppendLine($"{indent}        global::System.Collections.Immutable.ImmutableArray<TKey>? targets)");
        sb.AppendLine($"{indent}        where TKey : global::System.IEquatable<TKey>");
        sb.AppendLine($"{indent}    {{");

        foreach (var receiver in receivers)
        {
            var safeTypeName = GetSafeTypeName(receiver.InterfaceName);
            sb.AppendLine($"{indent}        if (typeof(T) == typeof({receiver.InterfaceType}))");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            return (T)(object)new {safeTypeName}_InMemoryProxy<TKey>(");
            sb.AppendLine($"{indent}                (global::Cysharp.Runtime.Multicast.InMemory.IReceiverHolder<TKey, {receiver.InterfaceType}>)(object)receivers,");
            sb.AppendLine($"{indent}                excludes,");
            sb.AppendLine($"{indent}                targets);");
            sb.AppendLine($"{indent}        }}");
        }

        sb.AppendLine($"{indent}        throw new global::System.NotSupportedException($\"The type '{{typeof(T)}}' is not supported. Please add it to the [MulticasterProxyGeneration] attribute.\");");
        sb.AppendLine($"{indent}    }}");
        sb.AppendLine();

        // IRemoteProxyFactory.Create<T>
        sb.AppendLine($"{indent}    /// <inheritdoc />");
        sb.AppendLine($"{indent}    public T Create<T>(");
        sb.AppendLine($"{indent}        global::Cysharp.Runtime.Multicast.Remoting.IRemoteReceiverWriter writer,");
        sb.AppendLine($"{indent}        global::Cysharp.Runtime.Multicast.Remoting.IRemoteSerializer serializer)");
        sb.AppendLine($"{indent}    {{");

        foreach (var receiver in receivers)
        {
            var safeTypeName = GetSafeTypeName(receiver.InterfaceName);
            sb.AppendLine($"{indent}        if (typeof(T) == typeof({receiver.InterfaceType}))");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            return (T)(object)new {safeTypeName}_RemoteProxy(writer, serializer);");
            sb.AppendLine($"{indent}        }}");
        }

        sb.AppendLine($"{indent}        throw new global::System.NotSupportedException($\"The type '{{typeof(T)}}' is not supported. Please add it to the [MulticasterProxyGeneration] attribute.\");");
        sb.AppendLine($"{indent}    }}");

        sb.AppendLine($"{indent}}}");
    }

    static string GetSafeTypeName(string typeName)
    {
        return typeName.Replace(".", "_").Replace("<", "_").Replace(">", "_").Replace(",", "_");
    }
}
